1.扩容机制

2.索引的基本原理
把创建了索引的列的内容进行了排序，对排序的结果生成了倒排表，在倒排表内容上拼上了数据的地址链
在查询的时候先拿到倒排表内容，在取出地址链从而拿到具体的数据
建立了索引的数据，就是通过事先排好序，在查找时可以应用二分查找来提高查询效率 






索引失效
尽量避免使用in和not in 会导致数据库引擎放弃索引
尽量避免对null值得判断，会导致数据库引擎放弃索引
对于多列索引，不是使用的第一部分，则不会使用索引
like查询以%开头
如果mysql预计使用全表扫描要比索引快 则不使用索引


新生代Eden：新对象和没有达到一定年龄的对象保存在该区域。
老年代Tenured：新创建的超大对象，长时间被使用的对象GC清理后还存活的对象。
元空间：像一些方法中操作的参数，临时的对象都保存在元空间；

子链表大于8 总容量大于64时

引用计数算法：
判断对象的引用数量来决定对象是否可以被回收
每个对象实例都有一个引用计数器，被引用则+1 完成引用则-1
任何引用计数为0的对象实列可以被当作垃圾收集

ConcurentHashMap是线程安全的，但是与Hashtable相比，实现线程安全的方式不同
Hashtable是通过对hash表结构进行锁定，是阻塞式的，当一个线程占有这个锁时
其他线程必须阻塞等待其释放锁。

ConcurentHashMap是采用分离锁的方式，它并没有对整个表进行锁定
而实局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。

在jdk1.8中，ConcurentHashMap不在使用Segment


-一次会话
一次会话：浏览器第一次给浏览器资源发送请求，会话建立，知道一方断开为止



-行专列- case when以及sum（max也可以）
列转行的话使用union和case when以及concat来完成







rabbitmq有重连机制 retry 通过设置retryTemplate来设置重连次数
到了重连次数还是没连上 这时候就会报异常
我们捕获这个歌异常 然后把消息存入缓存中
等环境正常后 做消息补发




String 字符串  做简单的键值对缓存
List 列表 存储一些列表型的数据结构
Set 无序集合 交集、并集、差集的操作
Zset 有序集合 可以去重排序
Hash 存储结构化数据

TCC解决方案
try阶段主要是对业务系统做检测一级资源预留，完成业务的准备工作
confirm阶段主要堆业务系统做提交 try阶段执行成功并开始执行Confirm阶段时
Confirm阶段是不回出错的。只要try成功Confirm一定成功
Cancel 阶段主要在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放











#### 配置nginx负载均衡 upstream 配置

#### RESTful风格
RESTful是一种架构的风格，他要求每个资源都是用URL得到一个唯一的地址。所有资源都
共享同一的接口，以便在客户端和服务器之间传输状态。使用的是标准的HTTP方法。

####rabbitMQ
简单模式：只有一个消费者
工作模式：多个消费者 从同一个队列接收数据 
发布和订阅者模式：把消息群发给所有消费者 同一条消息所有消费者都可以接收到
路由模式：通过关键词来匹配，来确定把消息发送到哪个队列
主题模式：和路由模式相同，具有特殊的关键词匹配规则 *代表一个 #代表0个或者多个

####视图其实就是一条查询sql语句，将一个查询的结果作为一个表来使用可以看作是一张虚拟表
create view



springboot默认数据源HikariCP
yml文件支持多文档  用---来分隔
spring:
  profiles:
    active: prod

改变this指向有四种方式
1.保存变量
2.bind
3.call
4.apply